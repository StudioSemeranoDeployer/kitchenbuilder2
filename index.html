<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Studio 3D | Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter+Tight:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #f4f2f0;
            --accent: #ff5722;
            --glass: rgba(255, 255, 255, 0.85);
            --glass-border: 1px solid rgba(255, 255, 255, 0.5);
            --blur: blur(20px);
            --text-main: #1a1a1a;
            --ease: cubic-bezier(0.23, 1, 0.32, 1);
        }

        body { margin: 0; overflow: hidden; font-family: 'Inter Tight', sans-serif; background: var(--bg-color); color: var(--text-main); height: 100vh; width: 100vw; user-select: none; -webkit-user-select: none; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; }

        /* HEADER */
        header { position: absolute; top: 0; left: 0; width: 100%; padding: 20px 30px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 20px; font-weight: 700; display: flex; align-items: center; gap: 8px; pointer-events: auto; }
        .badge { font-size: 9px; background: #000; color: white; padding: 3px 6px; border-radius: 4px; font-weight: 700; }
        .actions { display: flex; gap: 10px; pointer-events: auto; }
        .icon-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--glass); backdrop-filter: var(--blur); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.05); font-size: 16px; border: var(--glass-border); }
        .icon-btn:active { transform: scale(0.9); }

        /* DOCK */
        #dock-wrapper { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 12px; pointer-events: none; width: 90%; max-width: 800px; }
        .dock { pointer-events: auto; background: rgba(20, 20, 20, 0.9); backdrop-filter: blur(25px); padding: 6px; border-radius: 24px; display: flex; gap: 4px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .dock-tab { padding: 10px 20px; border-radius: 18px; color: rgba(255,255,255,0.6); cursor: pointer; font-size: 13px; font-weight: 500; transition: 0.3s var(--ease); }
        .dock-tab:hover { color: white; background: rgba(255,255,255,0.1); }
        .dock-tab.active { background: white; color: black; font-weight: 700; transform: translateY(-2px); }

        /* CARDS */
        #cards-container { pointer-events: auto; display: flex; gap: 8px; overflow-x: auto; padding: 10px; background: var(--glass); backdrop-filter: var(--blur); border-radius: 24px; border: var(--glass-border); box-shadow: 0 10px 40px rgba(0,0,0,0.1); max-width: 100%; scrollbar-width: none; opacity: 0; transform: translateY(20px); transition: 0.4s var(--ease); }
        #cards-container.visible { opacity: 1; transform: translateY(0); }
        .card { min-width: 75px; height: 85px; background: white; border-radius: 16px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; cursor: pointer; transition: 0.2s; border: 1px solid transparent; }
        .card:hover { transform: translateY(-4px); box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .card:active { transform: scale(0.95); }
        .card-icon { font-size: 24px; }
        .card-label { font-size: 10px; font-weight: 600; color: #444; }
        .card.action-delete { color: #e74c3c; background: #fdedec; }

        /* LOADER */
        #loader { position: fixed; inset: 0; z-index: 9999; background: #f4f2f0; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .loader-spin { width: 40px; height: 40px; border: 4px solid #ddd; border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-spin"></div>
        <p style="margin-top:20px; font-size:12px; font-weight:600; opacity:0.6;">LOADING STUDIO</p>
    </div>

    <div id="ui-layer">
        <header>
            <div class="logo"><div style="width:16px; height:16px; background:var(--accent); border-radius:4px;"></div>GECO<span>.srl</span><div class="badge">V5</div></div>
            <div class="actions">
                <div class="icon-btn" onclick="app.toggleView()">üìê</div>
                <div class="icon-btn" onclick="app.screenshot()">üì∑</div>
            </div>
        </header>

        <div id="dock-wrapper">
            <div id="cards-container"></div>
            <div class="dock">
                <div class="dock-tab active" onclick="ui.setTab('kitchen', this)">Moduli</div>
                <div class="dock-tab" onclick="ui.setTab('appliances', this)">Elettro</div>
                <div class="dock-tab" onclick="ui.setTab('materials', this)">Finiture</div>
                <div class="dock-tab" onclick="ui.setTab('save', this)">File</div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- CONFIG ---
        const CONFIG = { snap: 10, bgColor: 0xf4f2f0 };
        const state = { modules: [], selected: null, dragging: false, history: [], color: 'white_matte' };
        
        let scene, camera, renderer, controls, raycaster;
        let mainGroup, labelsGroup, dragPlane;
        
        // --- SAFE UTILS ---
        const generateID = () => 'id_' + Math.random().toString(36).substr(2, 9);

        // --- PUBLIC API ---
        window.app = {
            spawn: (t) => core.spawn(t),
            color: (c) => core.setColor(c),
            delete: () => core.delete(),
            rotate: () => core.rotate(),
            duplicate: () => core.duplicate(),
            toggleView: () => core.toggleView(),
            screenshot: () => core.renderHQ(),
            reset: () => core.reset()
        };

        init();

        function init() {
            try {
                // RENDERER
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limita pixel ratio per performance
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(renderer.domElement);

                // SCENE
                scene = new THREE.Scene();
                scene.background = new THREE.Color(CONFIG.bgColor);
                scene.fog = new THREE.Fog(CONFIG.bgColor, 500, 3000);

                // ENVIRONMENT (Light & Reflections)
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
                pmremGenerator.dispose(); // IMPORTANTE: Pulisce memoria

                // LIGHTS
                const sun = new THREE.DirectionalLight(0xfff0e6, 1.5);
                sun.position.set(200, 500, 300);
                sun.castShadow = true;
                sun.shadow.mapSize.set(1024, 1024);
                sun.shadow.normalBias = 0.04;
                scene.add(sun);
                scene.add(new THREE.AmbientLight(0xffffff, 0.5));

                // CAMERA
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 5000);
                camera.position.set(350, 250, 350);
                camera.lookAt(0, 50, 0);

                // GROUPS
                mainGroup = new THREE.Group(); scene.add(mainGroup);
                labelsGroup = new THREE.Group(); scene.add(labelsGroup);
                
                // SHADOW CATCHER
                const shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.ShadowMaterial({ opacity: 0.1, color: 0x000000 }));
                shadowPlane.rotation.x = -Math.PI / 2; shadowPlane.receiveShadow = true; shadowPlane.position.y = 0.1;
                scene.add(shadowPlane);

                // DRAG PLANE
                dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshBasicMaterial({ visible: false }));
                dragPlane.rotation.x = -Math.PI / 2; scene.add(dragPlane);

                // CONTROLS
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.maxPolarAngle = Math.PI / 2 - 0.05;

                // EVENTS
                raycaster = new THREE.Raycaster();
                setupInteraction();
                window.addEventListener('resize', onResize);

                // START
                animate();
                ui.setTab('kitchen', document.querySelector('.dock-tab.active'));
                core.spawn('base_60'); // Demo
                
                // Remove Loader
                setTimeout(() => {
                    const l = document.getElementById('loader');
                    l.style.opacity = 0;
                    setTimeout(() => l.remove(), 500);
                }, 800);

            } catch (e) {
                alert("Errore WebGL: " + e.message);
            }
        }

        // --- CORE LOGIC ---
        const core = {
            defs: {
                base_60: {w:60, h:86, d:60, type:'cab'},
                base_90: {w:90, h:86, d:60, type:'cab'},
                drawers: {w:60, h:86, d:60, type:'drawers'},
                sink:    {w:90, h:86, d:60, type:'sink'},
                oven:    {w:60, h:86, d:60, type:'oven'},
                wall_60: {w:60, h:72, d:35, y:144, type:'cab_up'},
                hood:    {w:90, h:60, d:35, y:144, type:'hood'},
                tall_60: {w:60, h:216, d:60, type:'tall'},
                fridge:  {w:60, h:216, d:60, type:'fridge'},
                lamp:    {w:30, h:120, d:30, y:0, type:'lamp'}
            },

            spawn: (t) => {
                const def = core.defs[t] || core.defs['base_60'];
                // ID GENERATOR FIXATO
                const data = { id: generateID(), t, x:0, y:def.y||0, z:0, rot:0, color: state.color, ...def };
                
                if(state.modules.length > 0) data.x = state.modules[state.modules.length-1].x + 70;

                builder.build(data);
                state.modules.push(data);
                core.select(data);
            },

            select: (data) => {
                state.selected = data;
                labelsGroup.clear();
                if(data && data.mesh) {
                    const box = new THREE.BoxHelper(data.mesh, 0xff5722);
                    labelsGroup.add(box);
                }
                ui.refresh();
            },

            delete: () => {
                if(!state.selected) return;
                mainGroup.remove(state.selected.mesh);
                builder.dispose(state.selected.mesh);
                state.modules = state.modules.filter(m => m !== state.selected);
                core.select(null);
            },

            duplicate: () => {
                if(!state.selected) return;
                const s = state.selected;
                const def = core.defs[s.t];
                const data = { ...s, id: generateID(), x: s.x+20, z: s.z+20, mesh: null }; // Reset mesh null
                builder.build(data);
                state.modules.push(data);
                core.select(data);
            },

            rotate: () => {
                if(!state.selected) return;
                state.selected.rot += Math.PI / 2;
                builder.updatePos(state.selected);
                core.select(state.selected);
            },

            setColor: (c) => {
                state.color = c;
                if(state.selected) {
                    state.selected.color = c;
                    builder.build(state.selected);
                }
            },

            toggleView: () => {
                const isTop = camera.position.y > 600;
                if(isTop) {
                    camera.position.set(350, 250, 350);
                    controls.target.set(0, 50, 0);
                } else {
                    camera.position.set(0, 800, 0);
                    controls.target.set(0, 0, 0);
                }
            },
            
            renderHQ: () => {
                renderer.render(scene, camera);
                const a = document.createElement('a');
                a.download = 'Render.png';
                a.href = renderer.domElement.toDataURL('image/png'); a.click();
            },

            reset: () => {
                if(confirm('Reset Project?')) {
                    state.modules.forEach(m => mainGroup.remove(m.mesh));
                    state.modules = [];
                    core.select(null);
                }
            }
        };

        // --- BUILDER ---
        const builder = {
            materials: {},
            getMat: (id) => {
                if(builder.materials[id]) return builder.materials[id];
                const pbr = (c, r=0.5, m=0) => new THREE.MeshPhysicalMaterial({ color:c, roughness:r, metalness:m });
                let mat;
                if(id === 'white_matte') mat = pbr(0xffffff, 0.9);
                else if(id === 'white_gloss') { mat = pbr(0xffffff, 0.1); mat.clearcoat=1; }
                else if(id === 'black') mat = pbr(0x222222, 0.8);
                else if(id === 'sage') mat = pbr(0x9caf88, 0.8);
                else if(id === 'navy') mat = pbr(0x2c3e50, 0.8);
                else if(id === 'wood') mat = builder.woodTex(0xd2b48c);
                else if(id === 'steel') mat = pbr(0xcccccc, 0.3, 0.8);
                else if(id === 'glass') { mat = pbr(0xffffff, 0, 0); mat.transmission=0.9; mat.opacity=0.3; mat.transparent=true; }
                else mat = pbr(0xffffff, 0.5);
                builder.materials[id] = mat;
                return mat;
            },
            woodTex: (col) => {
                const c = document.createElement('canvas'); c.width=256; c.height=256;
                const x = c.getContext('2d'); x.fillStyle='#'+new THREE.Color(col).getHexString(); x.fillRect(0,0,256,256);
                x.globalAlpha=0.1; for(let i=0;i<50;i++){ x.beginPath(); x.moveTo(0,Math.random()*256); x.bezierCurveTo(100,Math.random()*256,200,Math.random()*256,256,Math.random()*256); x.stroke(); }
                return new THREE.MeshPhysicalMaterial({ map:new THREE.CanvasTexture(c), roughness:0.7 });
            },
            build: (data) => {
                if(data.mesh) { mainGroup.remove(data.mesh); builder.dispose(data.mesh); }
                const g = new THREE.Group(); g.userData = { isModule: true, id: data.id };
                const mat = builder.getMat(data.color);
                const { w, h, d, type } = data;
                const toe = (['cab_up','hood','lamp'].includes(type)) ? 0 : 10;
                const bodyH = h - toe;

                if(toe > 0) {
                    const kick = new THREE.Mesh(new THREE.BoxGeometry(w-4, toe, d-4), builder.getMat('black'));
                    kick.position.set(0, toe/2, -2); g.add(kick);
                }

                if(type === 'lamp') {
                     const pole = new THREE.Mesh(new THREE.CylinderGeometry(2,2,h), builder.getMat('black'));
                     pole.position.y = h/2;
                     const shade = new THREE.Mesh(new THREE.ConeGeometry(20, 20, 32, 1, true), builder.getMat('white_matte'));
                     shade.position.y = h-10;
                     const light = new THREE.PointLight(0xffaa00, 3, 100); light.position.y = h-15;
                     g.add(pole, shade, light);
                } else if (type === 'hood') {
                    const box = new THREE.Mesh(new THREE.BoxGeometry(w, 40, d), builder.getMat('steel'));
                    box.position.y = 20; g.add(box);
                } else {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(w, bodyH, d), mat);
                    body.position.set(0, toe + bodyH/2, 0);
                    body.castShadow = true; body.receiveShadow = true;
                    g.add(body);
                    
                    // Door Detail (Procedural)
                    const door = new THREE.Mesh(new THREE.BoxGeometry(w-0.5, bodyH-0.5, 2), mat);
                    door.position.set(0, toe + bodyH/2, d/2+1); door.castShadow=true;
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(w/3, 1, 2), builder.getMat('black'));
                    handle.position.set(0, bodyH/2-5, 2);
                    door.add(handle);
                    g.add(door);
                }
                
                g.position.set(data.x, data.y, data.z);
                g.rotation.y = data.rot;
                mainGroup.add(g);
                data.mesh = g;
            },
            updatePos: (d) => { d.mesh.position.set(d.x, d.y, d.z); d.mesh.rotation.y = d.rot; },
            dispose: (o) => o.traverse(c => { if(c.geometry)c.geometry.dispose(); })
        };

        // --- INTERACTION ---
        function setupInteraction() {
            let offset = new THREE.Vector3();
            renderer.domElement.addEventListener('pointerdown', e => {
                const hits = getIntersect(e, mainGroup.children);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent !== mainGroup) obj = obj.parent;
                    if(obj.userData.isModule) {
                        state.dragging = true; controls.enabled = false;
                        const data = state.modules.find(m => m.id === obj.userData.id);
                        core.select(data);
                        const planeHit = getIntersect(e, [dragPlane])[0];
                        if(planeHit) offset.copy(planeHit.point).sub(obj.position);
                    }
                } else {
                    const bgHit = getIntersect(e, [dragPlane]);
                    if(bgHit.length>0 && !state.dragging) core.select(null);
                }
            });
            renderer.domElement.addEventListener('pointermove', e => {
                if(!state.dragging || !state.selected) return;
                const hit = getIntersect(e, [dragPlane])[0];
                if(hit) {
                    let tx = hit.point.x - offset.x, tz = hit.point.z - offset.z;
                    // SNAPPING
                    const s = state.selected;
                    state.modules.forEach(other => {
                        if(other === s) return;
                        const dx = tx - other.x, dz = tz - other.z;
                        if(Math.abs(dz) < 10 && Math.abs(Math.abs(dx) - (s.w/2 + other.w/2)) < 15) {
                            tx = other.x + (dx > 0 ? (s.w/2 + other.w/2) : -(s.w/2 + other.w/2));
                            tz = other.z;
                        }
                    });
                    s.x = tx; s.z = tz;
                    builder.updatePos(s);
                    core.select(s);
                }
            });
            renderer.domElement.addEventListener('pointerup', () => { state.dragging = false; controls.enabled = true; });
        }
        function getIntersect(e, list) {
            const r = renderer.domElement.getBoundingClientRect();
            raycaster.setFromCamera({ x: ((e.clientX - r.left)/r.width)*2-1, y: -((e.clientY - r.top)/r.height)*2+1 }, camera);
            return raycaster.intersectObjects(list, true);
        }

        // --- UI ---
        const ui = {
            menus: {
                kitchen: [ {n:'Base 60',i:'‚óªÔ∏è',a:()=>app.spawn('base_60')}, {n:'Base 90',i:'‚ñ≠',a:()=>app.spawn('base_90')}, {n:'Sink',i:'üö∞',a:()=>app.spawn('sink')}, {n:'Tall',i:'‚ñÆ',a:()=>app.spawn('tall_60')}, {n:'Wall',i:'‚ñ´Ô∏è',a:()=>app.spawn('wall_60')} ],
                appliances: [ {n:'Fridge',i:'‚ùÑÔ∏è',a:()=>app.spawn('fridge')}, {n:'Hood',i:'üí®',a:()=>app.spawn('hood')}, {n:'Oven',i:'üç≥',a:()=>app.spawn('oven')} ],
                materials: [ {n:'White',i:'‚ö™',a:()=>app.color('white_matte')}, {n:'Gloss',i:'‚ú®',a:()=>app.color('white_gloss')}, {n:'Sage',i:'üü¢',a:()=>app.color('sage')}, {n:'Navy',i:'üîµ',a:()=>app.color('navy')}, {n:'Wood',i:'üå≥',a:()=>app.color('wood')} ],
                save: [ {n:'Clear',i:'üóë',a:()=>app.reset()} ]
            },
            currentCat: null,
            setTab: (cat, el) => {
                ui.currentCat = cat;
                document.querySelectorAll('.dock-tab').forEach(e=>e.classList.remove('active'));
                el.classList.add('active');
                ui.renderCards(cat);
            },
            refresh: () => { if(ui.currentCat) ui.renderCards(ui.currentCat); },
            renderCards: (cat) => {
                const con = document.getElementById('cards-container');
                con.classList.remove('visible');
                setTimeout(() => {
                    con.innerHTML = '';
                    if(state.selected && cat !== 'save') {
                         [{n:'Rotate',i:'‚Üª',a:app.rotate}, {n:'Clone',i:'üìë',a:app.duplicate}, {n:'Delete',i:'‚úï',a:app.delete, cls:'action-delete'}].forEach(b => ui.addCard(con, b));
                         const div = document.createElement('div'); div.style.borderRight='1px solid rgba(0,0,0,0.1)'; div.style.margin='0 5px'; con.appendChild(div);
                    }
                    (ui.menus[cat]||[]).forEach(i => ui.addCard(con, i));
                    con.classList.add('visible');
                }, 200);
            },
            addCard: (p, i) => {
                const c = document.createElement('div'); c.className = `card ${i.cls||''}`;
                c.innerHTML = `<div class="card-icon">${i.i}</div><div class="card-label">${i.n}</div>`;
                c.onclick = i.a; p.appendChild(c);
            }
        };

        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>
</html>
